<?php
declare(strict_types=1);

ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);

// Load Composer autoloader
require_once __DIR__ . '/vendor/autoload.php';

use FlatLeap\LeapDB;

// ---- USAGE ----
if (!isset($is_installer)) {
    $argv = $_SERVER['argv'] ?? [];
    if (count($argv) < 2) {
        fwrite(STDERR, "Usage:\n  php gen.php <table> [schema1,schema2,...]\n  php gen.php all [schema1,schema2,...]\n");
        exit(1);
    }
    $target = $argv[1];
    $schemasArg = $argv[2] ?? 'public';
    $schemas = array_map('trim', explode(',', $schemasArg));
}

final class LeapGenerator
{
    public $db;
    public function __construct(private string $schema, private ?string $tableOrAll)
    {
        $this->db = new LeapDB();
    }

    public function generate(): void
    {
        if ($this->tableOrAll === null || strtolower($this->tableOrAll) === 'all') {
            foreach ($this->listTables() as $t) {
                $this->generateModel($t);
            }
            return;
        }

        $this->generateModel($this->tableOrAll);
    }

    /** @return string[] */
    private function listTables(): array
    {
        $sql = <<<SQL
SELECT table_name
FROM information_schema.tables
WHERE table_schema = :schema
  AND table_type = 'BASE TABLE'
ORDER BY table_name
SQL;
        $stmt = $this->db->connection->prepare($sql);
        $stmt->execute([':schema' => $this->schema]);
        return array_map(static fn ($r) => $r['table_name'], $stmt->fetchAll());
    }

    private function generateModel(string $table): void
    {
        $columns = $this->getColumns($table);
        if (!$columns) {
            fwrite(STDERR, "No columns found for {$this->schema}.{$table}" . PHP_EOL);
            return;
        }
        $pkCols = $this->getPrimaryKey($table);

        // Build $cols array with pg-specific details
        $pk = $pkCols[0] ?? 'id';
        $colsArray = [];
        foreach ($columns as $col) {
            $name = $col['column_name'];
            $type = $this->mapPgType($col['data_type'], $col['udt_name']);
            $isPrimary = in_array($name, $pkCols, true);
            $isIdentity = ($col['is_identity'] === 'YES') ||
              (is_string($col['column_default']) && str_starts_with($col['column_default'], 'nextval('));

            $colsArray[$name] = [
              'type'    => $type,
              'primary' => $isPrimary,
              'null'    => ($col['is_nullable'] === 'YES'),
              'default' => $col['column_default'],
              'extra'   => $isIdentity ? 'identity' : null,
            ];
        }

        $classBase   = $this->studly($table);
        $propsDoc    = $this->buildPropsDoc($columns);
        $colsExport  = $this->prettyExport($colsArray);

        $php = <<<PHP
<?php
declare(strict_types=1);

namespace App\Models;

use FlatLeap\LeapModel;

/**
 * Auto-generated by gen.php from FaltLeap
 * Table: {$this->schema}.{$table}
{$propsDoc}
 */
class {$classBase} extends LeapModel
{
    /** @var string */
    public string \$table = '{$table}';

    /** @var string Schema name */
    public string \$schema = '{$this->schema}';

    /** @var string Primary key column */
    public string \$pk = '{$pk}';

    /** @var array<string, array{type:string,primary:bool,null:bool,default:mixed,extra:mixed}> */
    public array \$cols = {$colsExport};

    public function __construct(\$id = null)
    {
        parent::__construct(\$id);
    }

    public function getTableName(): string
    {
        return '{$table}';
    }

    public function getSchemaName(): string
    {
        return '{$this->schema}';
    }

    public function getFullTableName(): string
    {
        return '{$this->schema}.{$table}';
    }
}

PHP;

        $outDir = __DIR__ . '/models';
        if (!is_dir($outDir) && !mkdir($outDir, 0775, true) && !is_dir($outDir)) {
            throw new RuntimeException("Failed to create models directory: $outDir");
        }

        $outFile = $outDir . '/' . $classBase . '.model.php';
        file_put_contents($outFile, $php);
        echo "Generated: {$outFile}" . PHP_EOL;
    }

    /** @return array<int, array{column_name:string,data_type:string,udt_name:string,is_nullable:string,column_default:?string,is_identity:string}> */
    private function getColumns(string $table): array
    {
        // Use information_schema for portable metadata; include is_identity when available
        $sql = <<<SQL
SELECT
  c.column_name,
  c.data_type,
  c.udt_name,
  c.is_nullable,
  c.column_default,
  COALESCE(c.is_identity, 'NO') AS is_identity
FROM information_schema.columns c
WHERE c.table_schema = :schema
  AND c.table_name   = :table
ORDER BY c.ordinal_position
SQL;
        $stmt = $this->db->connection->prepare($sql);
        $stmt->execute([':schema' => $this->schema, ':table' => $table]);
        return $stmt->fetchAll();
    }

    /** @return string[] column names in PK order */
    private function getPrimaryKey(string $table): array
    {
        $sql = <<<SQL
SELECT kcu.column_name
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
  ON tc.constraint_name = kcu.constraint_name
 AND tc.table_schema    = kcu.table_schema
WHERE tc.constraint_type = 'PRIMARY KEY'
  AND tc.table_schema = :schema
  AND tc.table_name   = :table
ORDER BY kcu.ordinal_position
SQL;
        $stmt = $this->db->connection->prepare($sql);
        $stmt->execute([':schema' => $this->schema, ':table' => $table]);
        return array_map(static fn ($r) => $r['column_name'], $stmt->fetchAll());
    }

    private function mapPgType(string $dataType, string $udtName): string
    {
        $dt  = strtolower($dataType);
        $udt = strtolower($udtName);

        // Numeric
        if (str_contains($dt, 'int') || in_array($udt, ['int2', 'int4', 'int8', 'serial', 'serial4', 'serial8', 'bigserial', 'smallint', 'integer', 'bigint'], true)) {
            return 'int';
        }
        if (in_array($dt, ['numeric', 'decimal', 'real', 'double precision'], true)) {
            return 'float';
        }

        // Booleans
        if ($dt === 'boolean') {
            return 'bool';
        }

        // Datetime-ish
        if (in_array($dt, ['timestamp without time zone', 'timestamp with time zone', 'date', 'time without time zone', 'time with time zone'], true)) {
            return 'datetime';
        }

        // JSON
        if ($dt === 'json' || $dt === 'jsonb') {
            return 'json';
        }

        // Text / strings
        if (in_array($dt, ['character varying', 'character', 'text', 'uuid', 'citext'], true)) {
            return 'string';
        }

        // Bytea
        if ($dt === 'bytea') {
            return 'binary';
        }

        // Arrays -> treat as json for your model schema
        if (str_ends_with($udt, '[]')) {
            return 'json';
        }

        // Fallback
        return 'string';
    }

    private function studly(string $s): string
    {
        $s = preg_replace('/[^a-zA-Z0-9]+/', ' ', $s);
        $s = ucwords(strtolower(trim($s)));
        return str_replace(' ', '', $s);
    }

    private function buildPropsDoc(array $columns): string
    {
        $lines = [];
        foreach ($columns as $col) {
            $name = $col['column_name'];
            $type = $this->mapPgType($col['data_type'], $col['udt_name']);
            $phpType = match ($type) {
                'int'      => 'int',
                'float'    => 'float',
                'bool'     => 'bool',
                'json'     => 'array|string',
                'binary'   => 'string', // raw bytes
                'datetime' => 'string|\DateTimeInterface',
                'text'     => 'string',
                default    => 'string|null',
            };
            $lines[] = " * @property {$phpType} \${$name}";
        }
        return implode(PHP_EOL, $lines);
    }

    private function prettyExport(array $arr): string
    {
        $export = var_export($arr, true);
        $export = preg_replace("/array \(/", "[", $export);
        $export = preg_replace("/\n\s*\),/", "],", $export);
        $export = preg_replace("/\)$/", "]", $export);
        return $export;
    }
}

// ---- RUN ----
foreach ($schemas as $schema) {
    echo "Generating models for schema: {$schema}" . PHP_EOL;
    $gen = new LeapGenerator($schema, strtolower($target) === 'all' ? null : $target);
    $gen->generate();
}
